<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MNIST Digit Recognizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #canvas {
            border: 2px solid #e5e7eb;
            cursor: crosshair;
            touch-action: none;
        }
        .prediction-card {
            transition: all 0.3s ease;
        }
        .prediction-bar {
            transition: width 0.5s ease;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen p-8">
    <div class="max-w-5xl mx-auto">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">MNIST Digit Recognizer</h1>
            <p class="text-gray-600">Draw a digit (0-9) and watch AI predict it in real-time</p>
        </div>

        <div class="grid md:grid-cols-2 gap-8">
            <!-- Drawing Area -->
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Draw Here</h2>
                <canvas id="canvas" width="280" height="280" class="mx-auto bg-white rounded-lg"></canvas>
                <div class="flex gap-3 mt-4">
                    <button id="clearBtn" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-semibold py-3 px-6 rounded-lg transition">
                        Clear
                    </button>
                    <button id="predictBtn" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition">
                        Predict
                    </button>
                </div>
            </div>

            <!-- Prediction Results -->
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Prediction</h2>
                
                <div id="resultArea" class="text-center mb-6">
                    <div id="emptyState" class="text-gray-400 py-12">
                        <svg class="w-16 h-16 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/>
                        </svg>
                        <p class="text-lg">Draw a digit to get started</p>
                    </div>

                    <div id="predictionResult" class="hidden">
                        <div class="text-7xl font-bold text-indigo-600 mb-2" id="predictedDigit">-</div>
                        <div class="text-sm text-gray-500 mb-1">Predicted Digit</div>
                        <div class="text-2xl font-semibold text-gray-700" id="confidence">--%</div>
                        <div class="text-xs text-gray-500">Confidence</div>
                    </div>
                </div>

                <div id="allPredictions" class="hidden">
                    <h3 class="text-sm font-semibold text-gray-600 mb-3">All Predictions</h3>
                    <div id="predictionBars" class="space-y-2"></div>
                </div>
            </div>
        </div>

        <div class="mt-8 bg-white rounded-xl shadow-lg p-6">
            <h3 class="text-lg font-semibold text-gray-700 mb-3">How It Works</h3>
            <div class="grid md:grid-cols-3 gap-4 text-sm text-gray-600">
                <div class="flex items-start gap-3">
                    <div class="bg-indigo-100 rounded-full p-2 mt-1">
                        <svg class="w-5 h-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                        </svg>
                    </div>
                    <div>
                        <div class="font-semibold text-gray-700">Pattern Analysis</div>
                        <div>Analyzes stroke density and distribution across canvas regions</div>
                    </div>
                </div>
                <div class="flex items-start gap-3">
                    <div class="bg-indigo-100 rounded-full p-2 mt-1">
                        <svg class="w-5 h-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z"/>
                        </svg>
                    </div>
                    <div>
                        <div class="font-semibold text-gray-700">Feature Detection</div>
                        <div>Identifies vertical lines, loops, curves, and symmetry patterns</div>
                    </div>
                </div>
                <div class="flex items-start gap-3">
                    <div class="bg-indigo-100 rounded-full p-2 mt-1">
                        <svg class="w-5 h-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                        </svg>
                    </div>
                    <div>
                        <div class="font-semibold text-gray-700">Smart Classification</div>
                        <div>Combines geometric features to predict the most likely digit</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const clearBtn = document.getElementById('clearBtn');
        const predictBtn = document.getElementById('predictBtn');
        
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Configure canvas drawing
        ctx.lineWidth = 20;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = '#000';

        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            if (e.type.includes('touch')) {
                lastX = (e.touches[0].clientX - rect.left) * scaleX;
                lastY = (e.touches[0].clientY - rect.top) * scaleY;
            } else {
                lastX = (e.clientX - rect.left) * scaleX;
                lastY = (e.clientY - rect.top) * scaleY;
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let currentX, currentY;
            if (e.type.includes('touch')) {
                currentX = (e.touches[0].clientX - rect.left) * scaleX;
                currentY = (e.touches[0].clientY - rect.top) * scaleY;
            } else {
                currentX = (e.clientX - rect.left) * scaleX;
                currentY = (e.clientY - rect.top) * scaleY;
            }

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();

            lastX = currentX;
            lastY = currentY;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        clearBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('emptyState').classList.remove('hidden');
            document.getElementById('predictionResult').classList.add('hidden');
            document.getElementById('allPredictions').classList.add('hidden');
        });

        predictBtn.addEventListener('click', predict);

        function predict() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Check if canvas is empty
            let hasDrawing = false;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    hasDrawing = true;
                    break;
                }
            }

            if (!hasDrawing) {
                alert('Please draw a digit first!');
                return;
            }

            // Analyze the drawing
            const features = analyzeDrawing(data, canvas.width, canvas.height);
            const predictions = classifyDigit(features);

            displayResults(predictions);
        }

        function analyzeDrawing(data, width, height) {
            // Divide canvas into regions
            const regions = {
                topLeft: 0, topCenter: 0, topRight: 0,
                midLeft: 0, midCenter: 0, midRight: 0,
                botLeft: 0, botCenter: 0, botRight: 0
            };

            let totalPixels = 0;
            let minX = width, maxX = 0, minY = height, maxY = 0;
            let centerX = 0, centerY = 0;

            // First pass: find bounds and center
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    if (data[i + 3] > 0) {
                        totalPixels++;
                        centerX += x;
                        centerY += y;
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            if (totalPixels === 0) return null;

            centerX /= totalPixels;
            centerY /= totalPixels;

            // Second pass: analyze regions
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    if (data[i + 3] > 0) {
                        const regionX = x < width / 3 ? 'Left' : x < 2 * width / 3 ? 'Center' : 'Right';
                        const regionY = y < height / 3 ? 'top' : y < 2 * height / 3 ? 'mid' : 'bot';
                        regions[regionY + regionX]++;
                    }
                }
            }

            const drawWidth = maxX - minX;
            const drawHeight = maxY - minY;

            return {
                regions,
                totalPixels,
                centerX,
                centerY,
                width: drawWidth,
                height: drawHeight,
                aspectRatio: drawWidth / drawHeight,
                topHeavy: regions.topLeft + regions.topCenter + regions.topRight,
                bottomHeavy: regions.botLeft + regions.botCenter + regions.botRight,
                leftHeavy: regions.topLeft + regions.midLeft + regions.botLeft,
                rightHeavy: regions.topRight + regions.midRight + regions.botRight,
                centerDense: regions.midCenter / totalPixels,
                vertical: drawHeight / drawWidth > 1.5
            };
        }

        function classifyDigit(features) {
            const scores = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

            // 0: Loop shape, center dense
            scores[0] = features.centerDense * 30 + 
                       (features.aspectRatio > 0.6 && features.aspectRatio < 1.2 ? 20 : 0) +
                       (features.regions.midCenter > features.totalPixels * 0.15 ? 15 : 0);

            // 1: Vertical line, center-heavy
            scores[1] = (features.vertical ? 40 : 0) + 
                       features.centerDense * 20 +
                       (features.aspectRatio < 0.5 ? 15 : 0);

            // 2: Top-right to bottom-left
            scores[2] = (features.regions.topRight > features.totalPixels * 0.15 ? 20 : 0) +
                       (features.regions.botLeft > features.totalPixels * 0.15 ? 20 : 0) +
                       (features.topHeavy > features.bottomHeavy ? 15 : 0);

            // 3: Right-heavy, two curves
            scores[3] = (features.rightHeavy / features.totalPixels) * 40 +
                       (features.regions.midRight > features.totalPixels * 0.15 ? 15 : 0);

            // 4: Top-heavy, right side
            scores[4] = (features.topHeavy / features.totalPixels) * 30 +
                       (features.rightHeavy / features.totalPixels) * 20 +
                       (features.regions.midLeft > features.totalPixels * 0.1 ? 15 : 0);

            // 5: Top-heavy, curves to right
            scores[5] = (features.topHeavy / features.totalPixels) * 25 +
                       (features.regions.botRight > features.totalPixels * 0.15 ? 20 : 0) +
                       (features.regions.topLeft > features.totalPixels * 0.1 ? 10 : 0);

            // 6: Loop at bottom
            scores[6] = (features.bottomHeavy / features.totalPixels) * 35 +
                       (features.regions.botCenter > features.totalPixels * 0.15 ? 20 : 0) +
                       (features.leftHeavy > features.rightHeavy ? 10 : 0);

            // 7: Top-heavy, diagonal
            scores[7] = (features.topHeavy / features.totalPixels) * 40 +
                       (features.regions.topCenter > features.totalPixels * 0.2 ? 15 : 0) +
                       (features.vertical ? 10 : 0);

            // 8: Center dense, balanced
            scores[8] = features.centerDense * 35 +
                       (Math.abs(features.topHeavy - features.bottomHeavy) < features.totalPixels * 0.1 ? 20 : 0) +
                       (features.regions.midCenter > features.totalPixels * 0.2 ? 15 : 0);

            // 9: Top loop, bottom line
            scores[9] = (features.topHeavy / features.totalPixels) * 30 +
                       (features.regions.topCenter > features.totalPixels * 0.15 ? 20 : 0) +
                       (features.rightHeavy > features.leftHeavy ? 15 : 0);

            // Normalize scores
            const maxScore = Math.max(...scores);
            return scores.map(s => Math.min(100, (s / maxScore) * 100));
        }

        function displayResults(predictions) {
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('predictionResult').classList.remove('hidden');
            document.getElementById('allPredictions').classList.remove('hidden');

            const maxIndex = predictions.indexOf(Math.max(...predictions));
            const confidence = predictions[maxIndex];

            document.getElementById('predictedDigit').textContent = maxIndex;
            document.getElementById('confidence').textContent = confidence.toFixed(1) + '%';

            const barsContainer = document.getElementById('predictionBars');
            barsContainer.innerHTML = '';

            predictions.forEach((score, digit) => {
                const barDiv = document.createElement('div');
                barDiv.className = 'flex items-center gap-3';
                barDiv.innerHTML = `
                    <div class="w-8 text-sm font-semibold text-gray-700">${digit}</div>
                    <div class="flex-1 bg-gray-200 rounded-full h-6 overflow-hidden">
                        <div class="prediction-bar bg-indigo-600 h-full rounded-full flex items-center justify-end pr-2" 
                             style="width: ${score}%">
                            <span class="text-xs text-white font-semibold">${score.toFixed(0)}%</span>
                        </div>
                    </div>
                `;
                barsContainer.appendChild(barDiv);
            });
        }
    </script>
</body>
</html>